
LINE_SENSOR_RIGHT = 4
LINE_SENSOR_LEFT = 3

Function FollowUntilCrossingAndTurnLeft()
  FollowLine(80, 0, 1, 0)
  Speaker.Tone(100,5000,10)
  DriveForDistanceNoAcc(20, 30)'move to place the robot spinning axis right on the crossing
  SpinLeft(90)
EndFunction

Function FollowUntilCrossingAndTurnRight()
  FollowLine(80, 0, 1, 0)
  Speaker.Tone(100,5000,10)
  DriveForDistanceNoAcc(20, 30)'move to place the robot spinning axis right on the crossing
  SpinRight(90)
EndFunction

Function DriveUntilLine(in number sensorPort)
  DriveUntilLine(sensorPort, 60, 1, 80, 20)
EndFunction

Function DriveUntilLine(in number sensorPort, in number speed)
  DriveUntilLine(sensorPort, speed, 1, 80, 20)
EndFunction

Function DriveUntilLine(in number sensorPort, in number speed, in number brake, in number white, in number black)
  'For i = 10 To speed
  '  Motor.StartSteer(@MOTORS,i,0)
  '  Program.Delay(2)
  'EndFor
  Motor.StartSteer(@MOTORS,speed,0)
  reading = Sensor.ReadPercent(sensorPort)
  While reading < white
    reading = Sensor.ReadPercent(sensorPort)
    LCD.Text(1,1,10,2,"S: "+reading+"  ")
  EndWhile
  Speaker.Tone(100,2000, 40)
  'Motor.StartSteer(@MOTORS,20,0)
  While reading > black
    reading = Sensor.ReadPercent(sensorPort)
    LCD.Text(1,1,10,2,"S: "+reading+"  ")
  EndWhile
  If brake <> 0 Then
    Motor.Stop(@MOTORS, "True")
  Else
    Motor.Stop(@MOTORS, "False")
  EndIf
  Speaker.Tone(100,2000, 40)
EndFunction

Function BackUpAlignCrossing()
  readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
  If readingR < 15 Then
    Motor.Start(@MOTOR_RIGHT,10)
    
    While readingR < 15
      readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
      LCD.Text(1,1,10,2,"R: "+readingR+"  ")
      Program.Delay(1)
    EndWhile
    Motor.Stop(@MOTOR_RIGHT,"True")
    Speaker.Tone(100, 1000, 30)
  EndIf
  
  Motor.Start(@MOTOR_RIGHT,-10)
  readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
  While readingR > 50
    readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
    LCD.Text(1,1,10,2,"R: "+readingR+"  ")
    Program.Delay(1)
  EndWhile
  Motor.Stop(@MOTOR_RIGHT,"True")
  Speaker.Tone(100, 2000, 30)
  
  readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
  
  If readingL < 15 Then
    Motor.Start(@MOTOR_LEFT,10)
    While readingL < 15
      readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
      LCD.Text(1,1,10,2,"L: "+readingL+"  ")
      Program.Delay(1)
    EndWhile
    Motor.Stop(@MOTOR_LEFT,"True")
    Speaker.Tone(100, 1000, 30)
    
    Motor.Start(@MOTOR_LEFT,-10)
    readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
    While readingL > 50
      readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
      LCD.Text(1,1,10,2,"L: "+readingL+"  ")
      Program.Delay(1)
    EndWhile
    Motor.Stop(@MOTOR_LEFT,"True")
    Speaker.Tone(100, 2000, 30)
  EndIf
EndFunction

Function FollowLineForDistance(in number distance)
  FollowLine(60, distance, 0, 1)
EndFunction

Function FollowLineUntilCrossing(in number speed)
  FollowLine(speed, 0, 1, 1)
EndFunction

Function FollowLineForDistanceUntilCrossing(in number distance)
  FollowLine(60, distance, 1, 1)
EndFunction

Function DriveUntilIntersection( in number speed)
  Time.Reset1()
  done = 0
  Motor.StartSteer(@MOTORS, speed, 0)
  While done = 0
    readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
    readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
    
    ' crossing detection
    If readingL > 25 Or readingR > 25 Then
      Time.Reset1()
    EndIf
    If Time.Get1() > 40 Then
      done = 1
    EndIf
    
  EndWhile
  Motor.Stop(@MOTORS,"True")
  Speaker.Tone(100, 4000, 20)
  
EndFunction

Function FollowLine(in number basePower, in number distanceBefore, in number untilCrossing, in number brake)
  eOld = 0
  error = 0
  
  ' stati del seguilinea
  S_DISTANCE = 0
  S_INTERSECTION = 1
  S_DONE = 2
  
  REFERENCE = 60
  LOW_POWER = 30
  
  'TODO abbassare guadagni, perché sono stati tarati con la batteria scarica
  ' e con la batteria piena, trema tutto
  KP_FAST = 0.8
  KP_SLOW = 0.4
  KD = 5
  SOGLIA_SCURA = 30
  
  angleToGo = @DISTANCE_FACTOR * distanceBefore
  
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  
  direction = 1
  If basePower < 0 Then ' se mai volessimo seguire la linea andando indietro...
    direction = -1
  EndIf
  
  lineFollowStatus = S_DISTANCE
  gain = KP_FAST
  power = basePower
  
  ' se la distanza da percorrere prima dell'incrocio è 0,
  ' allora vai subito in modalità ricerca incrocio
  If angleToGo = 0 Then
    lineFollowStatus = S_INTERSECTION
  EndIf
  
  Time.Reset1() ' timer per il rilevamento dell'incrocio
  
  While lineFollowStatus <> S_DONE
    Time.Reset2() ' timer per misurare il tempo di ciclo
    
    ' PID line following
    readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
    readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
    error = (REFERENCE - readingL)
    eD = error - eOld
    eOld = error
    
    If lineFollowStatus = S_DISTANCE Then
      ' sei su un incrocio, non sbandare! annulliamo la correzione
      If readingL < SOGLIA_SCURA And readingR < SOGLIA_SCURA Then
        gain = 0
      Else
        gain = KP_FAST
      EndIf
      
      ' misura la distanza percorsa 
      encLeft = Motor.GetCount(@MOTOR_LEFT)
      diff = Math.Abs(encLeft - pos0)
      
      If diff > angleToGo Then ' una volta raggiunta la distanza minima
        If untilCrossing = 0 Then ' se non devo cercare l'incrocio
          lineFollowStatus = S_DONE ' abbiamo finito
        Else ' se devo cercare l'incrocio...
          Speaker.Tone(100, 400, 30)
          Time.Reset1()
          power = LOW_POWER
          gain = KP_SLOW
          lineFollowStatus = S_INTERSECTION ' proseguiamo cercando l'incrocio
        EndIf
      EndIf
      
    ElseIf lineFollowStatus = S_INTERSECTION Then
      
      ' ogni volta che uno dei sensori non vede scuro, resettare timer
      If readingL > SOGLIA_SCURA Or readingR > SOGLIA_SCURA Then
        Time.Reset1()
      EndIf
      
      ' se entrambi i sensori vedono scuro sotto soglia per oltre 40ms, fermiamoci
      If Time.Get1() > 40 Then
        lineFollowStatus = S_DONE
      EndIf
      
    EndIf ' fine macchina a stati
    
    ' aggiorna motori se non abbiamo finito
    If lineFollowStatus <> S_DONE Then
      u = direction*gain*( error + KD*eD ) ' PD controller
      Motor.StartPower(@MOTOR_RIGHT, power + u)
      Motor.StartPower(@MOTOR_LEFT, power - u)
      timeLoop = Time.Get2()
      'LCD.Text(1,1,90,1,"T: "+timeLoop+" ms  ")
      Program.Delay(10-timeLoop)
    EndIf
    
  EndWhile
  
  If brake<>0 Then
    Motor.Stop(@MOTORS,"True")
  Else
    Motor.Stop(@MOTORS,"False")
  EndIf
EndFunction

' vecchio seguilinea bacato e poco leggibile
Function FollowLineOld(in number basePower, in number distanceBefore, in number untilCrossing, in number brake)
  eOld = 0
  error = 0
  REFERENCE = 60
  eI = 0
  LOW_POWER = 30
  cercaIncrocio = 0
  
  angleToGo = @DISTANCE_FACTOR * distanceBefore
  
  ' se la distanza da percorrere prima dell'incrocio è 0, allora bisogna fermarsi all'incrocio
  If angleToGo = 0 Then
    untilCrossing = 1
  EndIf
  
  'Motor.ResetCount(@MOTOR_LEFT)
  'Motor.ResetCount(@MOTOR_RIGHT)
  'Program.Delay(50)
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  direction = 1
  If basePower < 0 Then
    direction = -1
  EndIf
  
  Time.Reset1() ' timer per il rilevamento dell'incrocio
  done = 0
  While done = 0
    Time.Reset2() ' timer per misurare il tempo di ciclo
    ' PID line following
    readingR = Sensor.ReadPercent(@LINE_SENSOR_RIGHT)
    readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
    error = (REFERENCE - readingL)
    'error = readingL - readingR ' differential reading remove the need for calibration
    eD = error - eOld
    eOld = error
    
    'TODO abbassare guadagni, perché sono stati tarati con la batteria scarica
    ' con la batteria piena, trema tutto
    ' TODO abbassare guadagno e guadagno derivativo
    If cercaIncrocio = 0 Then
      u = direction*0.8*( error + 5*eD ) ' funziona a 100Hz, ma sculetta
    Else ' se sta cercando incrocio, abbassa velocità e guadagno
      u = direction*0.4*( error + 4*eD ) ' funziona a 100Hz, ma sculetta
    EndIf
    
    If readingL < 30 And readingR < 30 Then ' sei su un incrocio, non sbandare!
      'Speaker.Tone(100, 4000, 10)
      u = 0
    EndIf
    
    'If Math.Abs(error) > 30 Then
    '  power = basePower*0.8
    'Else
    power = basePower
    'EndIf
    
    ' distance measurement
    encLeft = Motor.GetCount(@MOTOR_LEFT)
    diff = Math.Abs(encLeft - pos0)
    If angleToGo <> 0 Then
      If diff > angleToGo Then
        power = LOW_POWER
        If untilCrossing <> 0 Then
          cercaIncrocio = 1
          'Speaker.Tone(100, 1400, 50)
        Else
          done = 1
          Speaker.Tone(100, 400, 50)
        EndIf
      Else
        If untilCrossing=1 Then
          Time.Reset1()
        EndIf
      EndIf
    EndIf
    
    ' ogni volta che uno dei sensori non vede scuro, resettare timer
    If readingL > 30 Or readingR > 30 Then
      Time.Reset1()
    EndIf
    
    ' se entrambi i sensori vedono scuro sotto soglia per oltre 40ms, fermiamoci
    If Time.Get1() > 40 Then
      done = 1
    EndIf
    
    If done = 0 Then
      'LCD.Text(1,1,10,1,"E: "+error+"  ")
      'LCD.Text(1,1,30,1,"U: "+u+"  ")
      Motor.StartPower(@MOTOR_RIGHT, power + u)
      Motor.StartPower(@MOTOR_LEFT, power - u)
      timeLoop = Time.Get2()
      'LCD.Text(1,1,90,1,"T: "+timeLoop+" ms  ")
      Program.Delay(10-timeLoop)
    EndIf
    
  EndWhile
  If brake<>0 Then
    Motor.Stop(@MOTORS,"True")
  Else
    Motor.Stop(@MOTORS,"False")
  EndIf
EndFunction