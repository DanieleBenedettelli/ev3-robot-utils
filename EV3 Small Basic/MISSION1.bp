folder "prjs" "WRO23"
include "ColorDetection"
include "DriveBase"
include "LineNavigation"
include "Grabber"

SLOW_SPEED = 20
NORMAL_SPEED = 50
FAST_SPEED = 70
MOTOR_RIGHT = "C"
MOTOR_LEFT = "B"
MOTOR_RAMP = "A"
MOTORS = MOTOR_RIGHT + MOTOR_LEFT
BLOCK_SENSOR = 2
LINE_SENSOR_RIGHT = 4
LINE_SENSOR_LEFT = 3

WHEEL_DIAMETER = 56 ' mm
WHEELBASE = 178 ' mm
DISTANCE_FACTOR = 2.03 ' 114.591559/WHEEL_DIAMETER
TURNING_FACTOR = 3.18 ' WHEELBASE / WHEEL_DIAMETER

DISTANCE_LARGE_BOAT = 220
DISTANCE_BLOCK1 = 140
DISTANCE_BLOCK2 = 200
DISTANCE_FUEL = 90
DISTANCE_FUEL_BACK = 85


DISTANCE_FIRST_BLOCK_LINE = 190
DISTANCE_DOCK_LINE = 300

SEARCH_FWD = 1
SEARCH_BACK = -1

Sub CalibrateRamp
  Motor.StartPower(MOTOR_RAMP,30)
  Program.Delay(500)
  Motor.Stop(MOTOR_RAMP, "True")
  Motor.ResetCount(MOTOR_RAMP)
EndSub

Sub UnloadRamp
  Motor.Move(MOTOR_RAMP, -10, 80, "True")
  Program.Delay(200)
  ' GO UP AGAIN
  Motor.StartPower(MOTOR_RAMP,50)
  Program.Delay(500)
  Motor.Stop(MOTOR_RAMP, "True")
  'degrees = Motor.GetCount(MOTOR_RAMP)
  'Motor.Move(MOTOR_RAMP, 30, degrees, "True")
EndSub

Sub RaiseRamp
  While Motor.IsBusy(MOTOR_RAMP)
    Speaker.Tone(100, 200, 40)
    Program.Delay(40)
  EndWhile
  Motor.StartPower(MOTOR_RAMP,50)
  Program.Delay(500)
  Motor.Stop(MOTOR_RAMP, "True")
EndSub

LCD.Clear()
Motor.Invert(MOTOR_LEFT)
Sensor.SetMode(LINE_SENSOR_LEFT, 0) ' set reflected light intensity mode
Sensor.SetMode(LINE_SENSOR_RIGHT, 0) ' set reflected light intensity mode
Sensor.SetMode(BLOCK_SENSOR, 4) ' RGB mode
Motor.ResetCount(MOTOR_GRABBER)
Motor.ResetCount(MOTOR_RAMP)

Motor.Stop(MOTORS,"True")
'CalibrateGrabber()




' AGGANCIA CONTAINER ROSSO

' SCARICA TUTTI CONTAINER SU BARCA GRANDE MENTRE PARCHEGGI

Program.Delay(500)
Program.End()

Function DriveAndScanOrder(in number distance, in number distanceBlock1, in number distanceBlock2, out string order1, out string order2)
  order1 = "NONE"
  order2 = "NONE"
  REFERENCE = 65
  
  'angleToGo = @DISTANCE_FACTOR * distance
  Motor.ResetCount(@MOTOR_LEFT)
  Motor.ResetCount(@MOTOR_RIGHT)
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  
  done = 0
  power = 60
  eOld = 0
  
  While done = 0
    Time.Reset2()' LOOP TIMER
    ' distance measurement
    encRight = Motor.GetCount(@MOTOR_RIGHT)
    encLeft = Motor.GetCount(@MOTOR_LEFT)
    travelDone = Math.Abs(encLeft - pos0) / @DISTANCE_FACTOR
    
    readingL = Sensor.ReadPercent(@LINE_SENSOR_LEFT)
    error = REFERENCE - readingL
    'error = readingL - readingR ' differential reading remove the need for calibration
    eD = error - eOld
    'eI = 0.8*eI + 0.05*error
    'eOld = error
    'u = -0.3*error '+ 0.008*eI + 0.15*eD
    
    'compensation = 0.5*(encRight - encLeft)
    compensation = 0.2*error '+ 1.5*eD  ' THIS WORKS @ 100Hz!!!!
    
    powerRight = power + compensation
    powerLeft = power - compensation
    
    'Motor.StartSync(@MOTORS, powerRight, powerLeft)
    Motor.StartPower(@MOTOR_LEFT, powerLeft)
    Motor.StartPower(@MOTOR_RIGHT, powerRight)
    
    'LCD.Text(1, 10, 60, 1, "travel = " + Math.round(travelDone)+ " mm  ")
    
    If travelDone > distanceBlock1-15 Then
      power = 40
    ElseIf travelDone > distanceBlock2+20 Then
      power = 60
    EndIf
    
    If order1 = "NONE" And (distanceBlock1-5) < travelDone And travelDone < (distanceBlock1+5) Then
      ReadColor(@BLOCK_SENSOR, 1, 1, color)
      If color <> "NONE" Then
        ReadColorRobust(@BLOCK_SENSOR, 1, robustColor)
        If robustColor <> "NONE" Then
          order1 = robustColor
          'Motor.Stop(@MOTORS,"True")
          'SayColor(order1,0)
          'Program.Delay(1000)
        EndIf
      EndIf
    EndIf
    
    If order2 = "NONE" And (distanceBlock2-5) < travelDone And travelDone < (distanceBlock2+5) Then
      ReadColor(@BLOCK_SENSOR, 1, 1, color)
      If color <> "NONE" Then
        ReadColorRobust(@BLOCK_SENSOR, 1, robustColor)
        If robustColor <> "NONE" Then
          order2 = robustColor
          'Motor.Stop(@MOTORS,"True")
          'SayColor(order2,0)
          'Program.Delay(1000)
        EndIf
      EndIf
    EndIf
    
    If travelDone > distance Then
      Motor.Stop(@MOTORS,"True")
      'Speaker.Tone(100,2000, 40)
      done = 1
    EndIf
    timeLoop = Time.Get2()
    LCD.Text(1, 10, 50, 2, "T: " + timeLoop + "  ")
    Program.Delay(10-timeLoop)
  EndWhile
  
  Motor.Stop(@MOTORS, "True")
  'Speaker.Wait()
  'Speaker.Tone(100,2000, 40)
  If order1 = "GREEN" Then
    @greenBlocksCount += 1
  EndIf
  If order1 = "BLUE" Then
    @blueBlocksCount += 1
  EndIf
  If order2 = "GREEN" Then
    @greenBlocksCount += 1
  EndIf
  If order2 = "BLUE" Then
    @blueBlocksCount += 1
  EndIf
  
EndFunction

Function CollectWhiteBlock()
  
  searchOver = 0
  blockColor = "NONE"
  blockOffset = -40 ' mm
  searchSpeed = -20
  maxDistanceToSearch = 100
  
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  found = 0
  
  Motor.StartSteer(@MOTORS, searchSpeed, 0)
  While searchOver = 0
    ReadColor(@BLOCK_SENSOR, @SHORT_RANGE, @SHOW_DEBUG, blockColor)
    If (blockColor<>"NONE") Then
      Motor.Stop(@MOTORS, "True")
      Speaker.Tone(100, 5000, 100)
      ReadColorRobust(@BLOCK_SENSOR, @SHORT_RANGE, blockColor)
      'LCD.Text(1, 10, 100, 1, "rob. color = " + blockColor + "  ")
      'SayColor(blockColor, 0)
      
      'If blockColor = "WHITE" Then
      DriveForDistanceNoAcc(blockOffset, 15)
      GrabAndDrop()
      searchOver = 1
      'Else
      DriveForDistanceNoAcc(blockOffset, 15) ' supera il blocco ignorato
      'EndIf
      
    EndIf
    
    encLeft = Motor.GetCount(@MOTOR_LEFT)
    diff = Math.Abs(encLeft - pos0)
    If diff > @DISTANCE_FACTOR * maxDistanceToSearch Then
      Motor.Stop(@MOTORS, "True")
      Speaker.Tone(100, 300, 500)
      searchOver = 1
    EndIf
  EndWhile
EndFunction

' distanza da dove parto a retromarcia col robot per prendere i blocchi per la barca grande
' e la linea dei container colorati


Function CollectBlocksLargeBoat(in number direction, in number maxDistanceToSearch)
  
  searchOver = 0
  blockColor = "NONE"
  blockOffset = 58 ' mm
  searchSpeed = 20
  
  If maxDistanceToSearch = 0 Then
    maxDistanceToSearch = 100 ' mm
  EndIf
  If direction < 0 Then
    searchSpeed *= -1
  EndIf
  
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  pos1 = pos0 ' usiamo questo punto per capire dove siamo rispetto alla linea
  found = 0
  
  Motor.StartSteer(@MOTORS, searchSpeed, 0)
  While searchOver = 0
    ReadColor(@BLOCK_SENSOR, @SHORT_RANGE, @SHOW_DEBUG, blockColor)
    If (blockColor<>"NONE") Then
      Motor.Stop(@MOTORS, "True")

      Speaker.Tone(100, 5000, 100)
      ReadColorRobust(@BLOCK_SENSOR, @SHORT_RANGE, blockColor)
      'LCD.Text(1, 10, 100, 1, "rob. color = " + blockColor + "  ")
      SayColor(blockColor, 0)
      
      If blockColor = "GREEN" or blockColor = "BLUE" Then
        DriveForDistanceNoAcc(blockOffset, 15)
        GrabAndDrop()
        found += 1
      'else
       ' DriveForDistanceNoAcc(blockOffset, 15) ' supera il blocco ignorato
      EndIf
      
      If found = 2 Then
        searchOver = 1
      Else ' start for the next
        pos0 = Motor.GetCount(@MOTOR_LEFT)
        Speaker.Tone(100, 3000, 100)
        Motor.StartSteer(@MOTORS, searchSpeed, 0)
      EndIf
    EndIf
    
    If found = 2 Then
      searchOver = 1
    EndIf
    
    encLeft = Motor.GetCount(@MOTOR_LEFT)
    diff = Math.Abs(encLeft - pos0)
    If diff > @DISTANCE_FACTOR * maxDistanceToSearch Then
      Motor.Stop(@MOTORS, "True")
      Speaker.Tone(100, 300, 500)
      searchOver = 1
    EndIf
  EndWhile
  
  travelFromBeginning = Math.Abs((Motor.GetCount(@MOTOR_LEFT) - pos1 )/@DISTANCE_FACTOR)
  
  'LCD.Clear()
  'LCD.Text(1, 5, 30, 1, "d: " + travelFromBeginning + " mm ")
  'LCD.Text(1, 5, 40, 1, "d: " + @DISTANCE_DOCK_LINE + " mm ")
  Program.Delay(2999)
  
  if travelFromBeginning > @DISTANCE_DOCK_LINE Then ' sono andato indietro oltre la linea nera
    'Speaker.Play(100, "Forward")
    DriveUntilLine(@LINE_SENSOR_LEFT, 20)
  Else
    'Speaker.Play(100, "Backward")
    DriveUntilLine(@LINE_SENSOR_LEFT, -20)
    EndIf
  
EndFunction

Function CollectBlocksSmallBoat(in number direction, in number maxDistanceToSearch)
  
  searchOver = 0
  blockColor = "NONE"
  blockOffset = 58 ' mm
  searchSpeed = 20
  
  If maxDistanceToSearch = 0 Then
    maxDistanceToSearch = 100 ' mm
  EndIf
  If direction < 0 Then
    'blockOffset *= -1
    searchSpeed *= -1
  EndIf
  
  pos0 = Motor.GetCount(@MOTOR_LEFT)
  found = 0
  saveDistance = 1
  
  Motor.StartSteer(@MOTORS, searchSpeed, 0)
  While searchOver = 0
    ReadColor(@BLOCK_SENSOR, @SHORT_RANGE, @SHOW_DEBUG, blockColor)
    If (blockColor<>"NONE") Then
      Motor.Stop(@MOTORS, "True")
      If saveDistance = 1 Then
        pos1 = Motor.GetCount(@MOTOR_LEFT)
        saveDistance = 0
      EndIf
      Speaker.Tone(100, 5000, 100)
      ReadColorRobust(@BLOCK_SENSOR, @SHORT_RANGE, blockColor)
      LCD.Text(1, 10, 100, 1, "rob. color = " + blockColor + "  ")
      SayColor(blockColor, 0)
      
      If blockColor = "GREEN" And @greenBlocksCount < 2 Then
        @greenBlocksCount += 1
        DriveForDistanceNoAcc(blockOffset, 15)
        GrabAndDrop()
        found += 1
      ElseIf blockColor = "BLUE" And @blueBlocksCount < 2 Then
        @blueBlocksCount += 1
        DriveForDistanceNoAcc(blockOffset, 15)
        GrabAndDrop()
        found += 1
      Else
        DriveForDistanceNoAcc(blockOffset, 15) ' supera il blocco ignorato
      EndIf
      
      If found = 2 Then
        searchOver = 1
      Else ' start for the next
        pos0 = Motor.GetCount(@MOTOR_LEFT)
        Speaker.Tone(100, 3000, 100)
        Motor.StartSteer(@MOTORS, searchSpeed, 0)
      EndIf
    EndIf
    
    If found = 2 Then
      searchOver = 1
    EndIf
    
    encLeft = Motor.GetCount(@MOTOR_LEFT)
    diff = Math.Abs(encLeft - pos0)
    If diff > @DISTANCE_FACTOR * maxDistanceToSearch Then
      Motor.Stop(@MOTORS, "True")
      Speaker.Tone(100, 300, 500)
      searchOver = 1
    EndIf
  EndWhile
  
  travelFromFirstBlock = (Motor.GetCount(@MOTOR_LEFT) - pos1 )
  distanceToLine = @DISTANCE_FIRST_BLOCK_LINE - travelFromFirstBlock/@DISTANCE_FACTOR
  'LCD.Clear()
  'LCD.Text(1, 5, 30, 1, "d: " + travelFromFirstBlock/@DISTANCE_FACTOR + " mm ")
  'LCD.Text(1, 5, 50, 1, "go: " + distanceToLine + " mm  ")
  DriveForDistanceNoAcc(distanceToLine, 50)
  
EndFunction

order1 = "NONE"
order2 = "NONE"
greenBlocksCount = 0
blueBlocksCount = 0

' CALIBRATION
Motor.Stop(MOTORS, "True")
'Motor.StartPower(MOTOR_RAMP,30)
'Program.Delay(1000)
'Motor.Stop(MOTOR_RAMP, "True")
CalibrateGrabber()

' ATTESA PULSANTE

Time.Reset9()

DriveUntilLine(LINE_SENSOR_LEFT, 30, 1, 65, 22)
DriveAndScanOrder(DISTANCE_LARGE_BOAT, DISTANCE_BLOCK1, DISTANCE_BLOCK2, order1, order2)

LCD.Clear()
LCD.Text(1, 10, 30, 1, "order1 = " + order1 + "  ")
LCD.Text(1, 10, 40, 1, "order2 = " + order2 + "  ")

SayColor(order1, 1)
SayColor(order2, 1)
'Program.Delay(2000)

' SPINGI E RIFORNISCI BARCA
DriveForDistance( DISTANCE_FUEL, 40 )
'Program.Delay(100)
DriveForDistanceNoAcc( DISTANCE_FUEL_BACK, -60)
'Program.Delay(1000)
' 1 secondo fino a qui

' VAI A CONTAINER A BATTUTA
SpinRight(90)
'Program.Delay(500)
FollowLine(50, 240, 0, 1)
'DriveForDistanceNoAcc(240, 70)
'FollowLine(40, 200, 0, 1)
'Program.Delay(500)
SpinRight(90)
'Program.Delay(500)
DriveForDistanceNoAcc(460,-60)
'Program.Delay(100)
Motor.StartPower(MOTORS,-50)
Program.Delay(400)
Motor.Stop(MOTORS,"True")
Program.Delay(100)

DriveForDistanceNoAcc(35,20) ' determina la distanza dai blocchi
ArcLeft(90)
LCD.Text(1, 2, 80, 2, "time: " + Time.Get9()/1000 + "  ")
CollectBlocksSmallBoat(SEARCH_FWD, 100)

' VAI DA CONTAINER A BARCA PICCOLA
SpinRight(90)
FollowLine(70, 250, 1, 0 ) ' coast at intersection, don't brake
'Motor.StartSteer(MOTORS, 70, 0)
'Program.Delay(400)
DriveForDistanceNoAcc(50, 40)
FollowLine(60, 220, 0, 1) ' keep following
DriveForDistanceNoAcc(40, 40)

ArcLeftNoAcc(135)
DriveUntilLine(@LINE_SENSOR_LEFT, 50, 1, 60, 25)
Program.Delay(200)
ArcRightNoAcc(45)
DriveForDistanceNoAcc(50, 40)

FollowLine(40, 160, 0, 1 ) ' non andare troppo avanti per non perdere tempo

' SCARICA POI SGANCIA BARCA
ArcLeft(10)
UnloadRamp()
ArcRight(10)
DriveForDistanceNoAcc(-30, 30)

' vai indietro fino a intersezione
DriveUntilIntersection(-40) ' indietro
DriveForDistanceNoAcc(50, 40) ' avanti per andare sulla linea
SpinLeft(90)

' VAI A PRENDERE IL BLOCCO BIANCO
FollowLine(50, 345, 0, 1) ' la distanza regola quanto si va vicini al blocco bianco
'Program.Delay(100)
SpinRight(90)
'CollectWhiteBlock()
DriveForDistanceNoAcc(-45, 30 ) ' distance, speed
GrabAndDrop()

' prendi blocchi colorati rimasti
DriveForDistanceNoAcc(-150, 70)
ArcLeft(-90)
' A battuta
Motor.StartPower(MOTORS,-50)
Program.Delay(400)
Motor.Stop(MOTORS,"True")
DriveForDistanceNoAcc(35,20) ' primo parametro determina la distanza dai blocchi
ArcLeft(90)

CollectBlocksLargeBoat(SEARCH_BACK, 380)

' PRENDI BARCA GRANDE
DriveForDistanceNoAcc(-150, 70)
ArcLeft(-90)
' A battuta
Motor.StartPower(MOTORS,-40)
Program.Delay(600)
Motor.Stop(MOTORS,"True")
DriveForDistanceNoAcc(75,20) ' primo parametro determina la l'allineamento alla barca
ArcRightNoAcc(90)
DriveForDistanceNoAcc(100,30)
' aggancia
ArcLeftNoAcc(135)
'vai verso linea
DriveUntilLine(LINE_SENSOR_LEFT, 30)
ArcLeftNoAcc(45)


' VAI FUORI DAL PORTO SPINGENDO ENTRAMBE LE BARCHE
FollowLine(70, 300, 1, 0 ) ' coast at intersection, don't brake
Motor.MoveSteer(@MOTORS, 70, 0, 40 *  @DISTANCE_FACTOR, "False")
FollowLine(70, 480, 1, 0 ) ' coast at intersection, don't brake
Motor.MoveSteer(@MOTORS, 70, 0, 40 *  @DISTANCE_FACTOR, "False")
FollowLine(70, 700, 1, 1 ) 


' manovra barca grande
DriveForDistanceNoAcc(30, 40)
ArcRightNoAcc(20)
'SpinRight(70)
ArcLeftNoAcc(-40)
DriveForDistanceNoAcc(90, 40)
ArcRightNoAcc(20)
Program.Delay(1000)

' vai contro la gru
FollowLine(60, 230, 0 ,1)
DriveForDistanceNoAcc(40, 70)

ArcRightNoAcc(20)
DriveForDistanceNoAcc(-200, 40)
SpinRight(180)
DriveForDistanceNoAcc(550, 80) ' usare muro come sponda per container da scaricare
UnloadRamp()

LCD.Text(1, 2, 100, 2, "time: " + Time.Get9()/1000 + "  ")
Program.Delay(10000)
